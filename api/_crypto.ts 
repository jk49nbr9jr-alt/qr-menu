// src/api/_crypto.ts
// PBKDF2 (SHA-256), kompatibel in Edge und Node runtimes

const ITER = 120_000;              // solide default
const KEYLEN = 32;                 // 256-bit
const SEP = "$";                   // format: pbkdf2$iter$saltHex$hashHex

function toHex(buf: ArrayBuffer) {
  const b = new Uint8Array(buf);
  return Array.from(b).map(x => x.toString(16).padStart(2, "0")).join("");
}
function fromHex(hex: string) {
  const out = new Uint8Array(hex.length / 2);
  for (let i = 0; i < out.length; i++) {
    out[i] = parseInt(hex.slice(i*2, i*2+2), 16);
  }
  return out;
}

export async function hashPassword(password: string, saltHex?: string): Promise<string> {
  const salt = saltHex ? fromHex(saltHex) : crypto.getRandomValues(new Uint8Array(16));
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveBits"]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", salt, iterations: ITER, hash: "SHA-256" },
    baseKey,
    KEYLEN * 8
  );
  const hashHex = toHex(bits);
  const sHex = toHex(salt.buffer as ArrayBuffer);
  return ["pbkdf2", String(ITER), sHex, hashHex].join(SEP);
}

export async function verifyPassword(password: string, stored: string): Promise<boolean> {
  const parts = stored.split(SEP);
  if (parts.length !== 4 || parts[0] !== "pbkdf2") return false;
  const iter = parseInt(parts[1], 10) || ITER;
  const salt = fromHex(parts[2]);
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveBits"]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", salt, iterations: iter, hash: "SHA-256" },
    baseKey,
    KEYLEN * 8
  );
  const hashHex = toHex(bits);
  return hashHex === parts[3];
}